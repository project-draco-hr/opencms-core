{
  try {
    Class.forName(contentDefinitionName).getMethod("beforePublish",new Class[]{CmsObject.class,Boolean.class,Integer.class,Integer.class,Long.class,Vector.class,Vector.class,CmsMasterDataSet.class}).invoke(null,new Object[]{cms,new Boolean(enableHistory),new Integer(subId),new Integer(versionId),new Long(publishingDate),changedRessources,changedModuleData,dataset});
  }
 catch (  Exception e) {
    CmsBase.log(CmsBase.C_MODULE_DEBUG,"[CmsDbAccess] error calling method beforePublish in class " + contentDefinitionName);
  }
  if (enableHistory) {
    long backupCreationDate=dataset.m_dateCreated;
    publishBackupData(cms,dataset,subId,versionId,publishingDate);
    dataset.m_dateCreated=backupCreationDate;
  }
  publishDeleteData(dataset.m_masterId,subId,"online");
  if (dataset.m_state == I_CmsConstants.C_STATE_DELETED) {
    publishDeleteData(dataset.m_masterId,subId,"offline");
  }
 else {
    publishCopyData(dataset,subId);
  }
  PreparedStatement stmnt=null;
  Connection con=null;
  try {
    con=DriverManager.getConnection(m_poolName);
    stmnt=sqlPrepare(con,"update_state_offline");
    stmnt.setInt(1,I_CmsConstants.C_STATE_UNCHANGED);
    stmnt.setInt(2,I_CmsConstants.C_UNKNOWN_ID);
    stmnt.setInt(3,dataset.m_masterId);
    stmnt.setInt(4,subId);
    stmnt.executeUpdate();
  }
 catch (  SQLException exc) {
    throw new CmsException(CmsException.C_SQL_ERROR,exc);
  }
 finally {
    sqlClose(con,stmnt,null);
  }
  changedModuleData.add(cms.getSiteName() + cms.C_ROOTNAME_COS + "/"+ contentDefinitionName+ "/"+ dataset.m_masterId);
}
