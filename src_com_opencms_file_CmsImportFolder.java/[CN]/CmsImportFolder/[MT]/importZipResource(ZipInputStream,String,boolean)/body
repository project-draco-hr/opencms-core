{
  boolean isFolder=false;
  boolean exit=false;
  int j, r, stop, charsRead, size;
  int entries=0;
  int totalBytes=0;
  int offset=0;
  byte[] buffer=null;
  while (true) {
    j=0;
    stop=0;
    charsRead=0;
    totalBytes=0;
    ZipEntry entry=zipStreamIn.getNextEntry();
    if (entry == null) {
      break;
    }
    entries++;
    String actImportPath=importPath;
    String filename=m_cms.getRequestContext().getFileTranslator().translateResource(entry.getName());
    StringTokenizer st=new StringTokenizer(filename,"/\\");
    int count=st.countTokens();
    String[] path=new String[count];
    if (filename.endsWith("\\") || filename.endsWith("/")) {
      isFolder=true;
    }
 else {
      isFolder=false;
    }
    while (st.hasMoreTokens()) {
      path[j]=st.nextToken();
      j++;
    }
    stop=isFolder == true ? path.length : path.length - 1;
    if (noSubFolder == true) {
      stop=0;
    }
    for (r=0; r < stop; r++) {
      try {
        m_cms.createResource(actImportPath,path[r],C_TYPE_FOLDER_NAME);
      }
 catch (      CmsException e) {
      }
      actImportPath+=path[r]+="/";
    }
    if (isFolder == false) {
      String type=getFileType(path[path.length - 1]);
      size=new Long(entry.getSize()).intValue();
      if (size == -1) {
        Vector v=new Vector();
        while (true) {
          buffer=new byte[512];
          offset=0;
          while (offset < buffer.length) {
            charsRead=zipStreamIn.read(buffer,offset,buffer.length - offset);
            if (charsRead == -1) {
              exit=true;
              break;
            }
            offset+=charsRead;
            totalBytes+=charsRead;
          }
          if (offset > 0) {
            v.addElement(buffer);
          }
          if (exit == true) {
            exit=false;
            break;
          }
        }
        buffer=new byte[totalBytes];
        offset=0;
        byte[] act=null;
        for (int z=0; z < v.size() - 1; z++) {
          act=(byte[])v.elementAt(z);
          System.arraycopy(act,0,buffer,offset,act.length);
          offset+=act.length;
        }
        act=(byte[])v.lastElement();
        if ((totalBytes > act.length) && (totalBytes % act.length != 0)) {
          totalBytes=totalBytes % act.length;
        }
 else         if ((totalBytes > act.length) && (totalBytes % act.length == 0)) {
          totalBytes=act.length;
        }
        System.arraycopy(act,0,buffer,offset,totalBytes);
        if (totalBytes == 0) {
          buffer=" ".getBytes();
        }
      }
 else {
        buffer=new byte[size];
        while (charsRead < size) {
          charsRead+=zipStreamIn.read(buffer,charsRead,size - charsRead);
        }
        if (size == 0) {
          buffer=" ".getBytes();
        }
      }
      filename=actImportPath + path[path.length - 1];
      Hashtable oldProperties=null;
      try {
        m_cms.lockResource(filename,true);
        oldProperties=m_cms.readAllProperties(filename);
        m_cms.deleteResource(filename);
      }
 catch (      CmsException e) {
      }
      try {
        m_cms.createResource(actImportPath,path[path.length - 1],type,null,buffer);
        if (oldProperties != null) {
          m_cms.writeProperties(filename,oldProperties);
        }
      }
 catch (      CmsException e) {
        throw new CmsException(CmsException.C_UNKNOWN_EXCEPTION,e);
      }
    }
    zipStreamIn.closeEntry();
  }
  zipStreamIn.close();
  if (entries > 0) {
    setValidZipFile(true);
  }
}
